pipeline {
    agent {
        label "OneS"
    }
    
    triggers {
        cron('H 20 * * *')  // Запускать каждый день в 20:00
    }
    
    environment {
        InitDatabase = "tests/scripts/InitDatabase.bat"
        dbTests = "avtotestqa"
    }
    
    stages {
        stage("Запуск") {
            steps {
                script {
                    def dropDbTasks = [:]
                    def backupTasks = [:]
                    def restoreTasks = [:]
                    def createDbTasks = [:]
                    def updateDbTasks = [:]
                    def runHandlers1cTasks = [:]
                    
                    for (i = 0; i < templatebasesList.size(); i++) {
                        def dbTests = templatebasesList[i]
                        def storage1cPath = storages1cPathList[i]
                        def testbase = "test_${dbTests}"
                        def testbaseConnString = projectHelpers.getConnString(server1c, testbase, agent1cPort)
                        def backupPath = "${env.WORKSPACE}/build/temp_${dbTests}_${utils.currentDateStamp()}"

                        // 1. Удаляем тестовую базу из кластера
                        dropDbTasks["dropDbTask_${testbase}"] = {
                            dropDbTask(
                                server1c, 
                                server1cPort, 
                                serverSql, 
                                testbase, 
                                admin1cUser, 
                                admin1cPwd,
                                sqluser,
                                sqlPwd
                            )
                        }

                        // 2. Делаем sql бекап эталонной базы
                        backupTasks["backupTask_${dbTests}"] = {
                            backupTask(
                                serverSql, 
                                dbTests, 
                                backupPath,
                                sqlUser,
                                sqlPwd
                            )
                        }

                        // 3. Загружаем sql бекап в тестовую базу
                        restoreTasks["restoreTask_${testbase}"] = {
                            restoreTask(
                                serverSql, 
                                testbase, 
                                backupPath,
                                sqlUser,
                                sqlPwd
                            )
                        }

                        // 4. Создаем тестовую базу в кластере 1С
                        createDbTasks["createDbTask_${testbase}"] = {
                            createDbTask(
                                "${server1c}:${agent1cPort}",
                                serverSql,
                                platform1c,
                                testbase
                            )
                        }

                        // 5. Обновляем тестовую базу из хранилища
                        updateDbTasks["updateTask_${testbase}"] = {
                            updateDbTask(
                                platform1c,
                                testbase, 
                                storage1cPath, 
                                storageUser, 
                                storagePwd, 
                                testbaseConnString, 
                                admin1cUser, 
                                admin1cPwd
                            )
                        }

                        // 6. Запускаем обработку для очистки базы
                        runHandlers1cTasks["runHandlers1cTask_${testbase}"] = {
                            runHandlers1cTask(
                                testbase, 
                                admin1cUser, 
                                admin1cPwd,
                                testbaseConnString
                            )
                        }
                    }

                    parallel dropDbTasks
                    parallel backupTasks
                    parallel restoreTasks
                    parallel createDbTasks
                    parallel updateDbTasks
                    parallel runHandlers1cTasks
                }
            }
        }
    }
    
    post {
        always {
            script {
                if (currentBuild.result == "ABORTED") {
                    return
                }

                dir('tests/build/results') {
                    writeFile file: 'environment.properties', text: "Build=${env.BUILD_URL}"
                }

                allure includeProperties: false, jdk: '', results: [[path: 'tests/build/results']]
                
                if (currentBuild.currentResult == "SUCCESS" || currentBuild.currentResult == "UNSTABLE") {
                    if ("${params.dbName}" == "VAFitness") {
                        env.logo = "tests/notifications/logo.png"
                    }
                    else if ("${params.dbName}" == "VASPA") {
                        env.logo = "tests/notifications/logo1.png"
                    }
                    else if ("${params.dbName}" == "VAStoma") {
                        env.logo = "tests/notifications/logo2.png"
                    }

                    def allureReportUrl = "${env.JENKINS_URL}job/${env.JOB_NAME.replaceAll('/', '/job/')}/${env.BUILD_NUMBER}/allure"
                    def configJson = readFile(file: 'tests/notifications/config.json')
                    def updatedConfigJson = configJson
                        .replace('"${allureReportUrl}"', "\"${allureReportUrl}\"")
                        .replace('"${JOB_NAME}"', "\"${env.JOB_NAME}\"")
                        .replace('"${logo}"', "\"${env.logo}\"")
                    writeFile(file: 'tests/notifications/config.json', text: updatedConfigJson)

                    try {
                        bat """java "-DconfigFile=tests/notifications/config.json" "-Dhttp.connection.timeout=60000" "-Dhttp.socket.timeout=120000" -jar tests/notifications/allure-notifications-4.8.0.jar"""
                    }
                    catch (Exception e) {
                        echo "Ошибка при отправке уведомления: ${e.message}. Продолжаем выполнение pipeline."
                    }
                }
            }
        }
    }
}

// Вспомогательные методы
def runDbOperation(operation, params) {
    try {
        bat """
            chcp 65001
            @call ${env.InitDatabase} ${operation} ${params}
        """
    } catch (Exception e) {
        echo "Ошибка при выполнении операции ${operation}: ${e.message}"
        throw e
    }
}

def updateConfigFile() {
    def configJson = readFile(file: 'tests/tools/VAParams.json')
    def updatedConfigJson = configJson.replaceAll(/\$\{product\}/, params.product)
    writeFile(file: 'tests/tools/VAParams.json', text: updatedConfigJson)
}

def killSessions(dbName) {
    try {
        runDbOperation("session_kill", "\"${dbName}\"")
    } catch (Exception e) {
        echo "⚠️ Не удалось отключить пользователей от базы ${dbName}: ${e.message}"
    }
}


def dropDbTask(server1c, server1cPort, serverSql, infobase, admin1cUser, admin1cPwd, sqluser, sqlPwd) {
    return {
        timestamps {
            stage("Удаление ${infobase}") {
                def projectHelpers = new ProjectHelpers()
                def utils = new Utils()

                projectHelpers.dropDb(server1c, server1cPort, serverSql, infobase, admin1cUser, admin1cPwd, sqluser, sqlPwd)
            }
        }
    }
}

def createDbTask(server1c, serverSql, platform1c, infobase) {
    return {
        stage("Создание базы ${infobase}") {
            timestamps {
                def projectHelpers = new ProjectHelpers()
                try {
                    projectHelpers.createDb(platform1c, server1c, serversql, infobase, null, false)
                } catch (excp) {
                    echo "Error happened when creating base ${infobase}. Probably base already exists in the ibases.v8i list. Skip the error"
                }
            }
        }
    }
}

def backupTask(serverSql, infobase, backupPath, sqlUser, sqlPwd) {
    return {
        stage("sql бекап ${infobase}") {
            timestamps {
                def sqlUtils = new SqlUtils()

                sqlUtils.checkDb(serverSql, infobase, sqlUser, sqlPwd)
                sqlUtils.backupDb(serverSql, infobase, backupPath, sqlUser, sqlPwd)
            }
        }
    }
}

def restoreTask(serverSql, infobase, backupPath, sqlUser, sqlPwd) {
    return {
        stage("Востановление ${infobase} бекапа") {
            timestamps {
                sqlUtils = new SqlUtils()

                sqlUtils.createEmptyDb(serverSql, infobase, sqlUser, sqlPwd)
                sqlUtils.restoreDb(serverSql, infobase, backupPath, sqlUser, sqlPwd)
            }
        }
    }
}

def runHandlers1cTask(infobase, admin1cUser, admin1cPwd, testbaseConnString) {
    return {
        stage("Запуск 1с обработки на ${infobase}") {
            timestamps {
                def projectHelpers = new ProjectHelpers()
                projectHelpers.unlocking1cBase(testbaseConnString, admin1cUser, admin1cPwd)
            }
        }
    }
}

def updateDbTask(platform1c, infobase, storage1cPath, storageUser, storagePwd, connString, admin1cUser, admin1cPwd) {
    return {
        stage("Загрузка из хранилища ${infobase}") {
            timestamps {
                prHelpers = new ProjectHelpers()

                if (storage1cPath == null || storage1cPath.isEmpty()) {
                    return
                }

                prHelpers.loadCfgFrom1CStorage(storage1cPath, storageUser, storagePwd, connString, admin1cUser, admin1cPwd, platform1c)
                prHelpers.updateInfobase(connString, admin1cUser, admin1cPwd, platform1c)
            }
        }
    }
}